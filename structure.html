<!DOCTYPE html>
<html lang="en" data-bs-theme="dark"><head>
  <meta charset="utf-8">
  <meta name="demoduleion" content="Sage-Code Eve projectâ€ž structure.">
  <meta name="author" content="Elucian Moise">
  <meta name="keywords" content="sage, code, EVE, project, language">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Website title -->
  <title>Eve Structure</title>

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
  <!-- Icon -->
  <link rel="icon" type="image/png"  href="https://sagecode.net/images/favicon.ico">
  <!-- Eve code highlighter -->
  <script src="eve.js"></script>
  <!-- Sage-Code custom CSS -->
  <link rel="stylesheet" href="https://sagecode.net/sage.css">
  </head>
<body onload="eve_render()">

<div class="container">

<!-- header -->
<div class="row">
    <div class="col">
        <a href="https://sagecode.net">
          <img src="https://sagecode.net/images/sage-logo.svg" alt="Sage-Code Laboratory" height="80">
        </a>
    </div>
    <div class="col  bottom-right">
        <a href="index.html#lang-index" rel="nofollow">index</a>&lt;--
    </div>
</div><hr>

<h1>Eve Structure</h1>

<div class="alert alert-secondary shadow-sm">
Eve is designed to quickly build a data processing app that can run several jobs in order on a precise schedule. You can create one module app but sometimes you need to divide a project into many small modules that run together.</div>

<h4>Page bookmarks:</h4>

<p>Next topics describe overal structure of Eve applications.</p>

<hr>

<ul>
<li><a href="#project">Project</a></li>
<li><a href="#scripts">Scripts</a></li>
<li><a href="#regions">Regions</a></li>
<li><a href="#drivers">Drivers</a></li>
<li><a href="#aspects">Aspects</a></li>
<li><a href="#modules">Modules</a></li>
<li><a href="#library">Library</a></li>
<li><a href="#execution">Execution</a></li>
<li><a href="#configuration">Configuration</a></li>
</ul>
<hr>

<h2><a id="project" href="#project"></a>Projects</h2>
<p>A project is a folder with a specific structure. It contains one or more applications that can run independent of each other on the same computer or a group of computers.</p>

<p><b>project structure</b></p>
<p>Next project contains two applications: server/agent and show folders where you should put your code (src+lib) and documentation (doc). This is a recommendation but not a hard rule.</p>

<pre><code class="language-bee">$pro_home
project
  |-- agent
  |   |-- aspect1.bee
  |   |-- aspect2.bee
  |   ...
  |-- server
  |   |--  aspect1.bee
  |   |--- aspect2.bee
  |   ...
  |-- library
  |   |-- module1
  |   |     |-- module_script1.bee
  |   |     |-- module_script2.bee
  |   |     ...
  |   |-- module2
  |   ... 
  |       
  |-- documents
  |   |-- readme.md
  |   |-- index.html
  |   ...
  |-- agent.eve
  |-- server.eve
</code></pre>

<h2><a id="scripts"></a>Scripts</h2>

<p>Eve define several kind of scripts that together makes a "project suite". Some scripts are reusable but some are specific to a single project. Here are all the possible scripts:</p>

<ul>
<li>Driver, created with keyword: "driver",</li>    
<li>Aspect, created with keyword: "aspect",</li>
<li>Module, created with keyword: "module",</li>
</ul>

<p><b>Notes:&nbsp;</b>One project can contain one or many drivers. Each driver is an independent script. A driver has a single executable process. Eve virtual machine can run a single driver at a time but several aspects in the same time. A driver can "import" modules and can "start" several aspects in parallel.</p>

<h4>Features:</h4>

<ul>
<li>A driver can import one or more modules;</li>
<li>A driver can <em>apply</em> aspects in sequence;</li>
<li>A driver can <em>start</em> aspects in parallel;</li>
<li>A driver can have at least one process that is the main process;</li>
<li>An aspect can be split into multiple other aspects;</li>
<li>An aspect can import several modules;</li>
<li>Modules can share states with all other scripts.</li>
</ul>

<h3><a id="regions"></a>Regions</h3>

<p>A script file is divided into regions using keywords: {import, alias, global, process}. Regions members are using indentation, like Python. A region ends when next region begins. Eve try to be flat as much as possible. Therefore these regions are right side aligned.</p>

<h4>Syntax Pattern:</h4>

<p>An Eve script begins with one of these keywords: {"driver", "aspect", "module"}. Script name is the same as the file name without the extension. A driver or aspect script can have parameters, defined after script name in a list, but a module do not have parameters.</p>

<pre><code class="language-eve">
+--------------------------------------------
 Header comments: explain the module purpose  
 These comments can be used on top of module      
---------------------------------------------+
[driver | aspect | module] name(parameters):

** set system variables
  set $sys_con    = value;
  ...

** import region
import
  from $path/library_name use (*);

** qualifier suppression region
alias
  AliasName1 = library_name.MemberName;
  AliasName2 = ClassName[parameters];
  ...

** define user types
class
  NewType  = {} &lt;: Type;
  ...
** define functions using Lambda expression
global
  set expression_name = (params) => (expression);
  ...
** global & shared states
global
  set local = value1: user_tupe;
  ...
----------------------------------------------------
** main process, or initialization region
[process | init]
  new my_var  = value;  -- private variable
  ...
[finalize | release]
  ** release locked resources & log reports
  ...
return;
-----------------------------------------------------
/* notes: can be used at the end of the script. 
   usually the notes use C like, block comments.
*/
</code></pre>


<h4>Members</h4>
<ul>
<li>a script can define members, visible in process;</li>
<li>a script can import public members from modules;</li>
<li>a script can "set" shared states using "$" sigil;</li>
</ul>

<p><b>Note: </b>Any script has one or more <em>global</em> regions. In this regions, you can set system states and define global states. In declaration region you can also define: classes, methods, functions & routines.</p> 

<p>All variables defined in global scope are static. You must use keyword "set" to define them and assign initial value. Static variables are created on the heap and have a permanent nature.</p>

<h3>System variables</h3>

<p><em>Shared states </em>use prefix "$". These are called system variables. Can be loaded from a configuration file (*.cfg). Eve modules and drivers cana define, initialize or reset values for shared states.</p>

<p><em>Shared states </em> can be defined in the first region after ":", after indentation. No need to use <em>global</em> keyword for this region. You need to use <em>global</em> if you declare some globals later before the process or init region.</p>

<h4>Note:</h4>
<ul>
<li>System states can be defined in a configuration file,</li>
<li>System states are usually defined in core modules,</li>
<li>System states can't be defined in aspects but overwriten,</li>
</ul>

<p>Several system variables are provided by Eve environment:</p>
<ul>
<li>$EVE_DIR  :eve runtime</li>
<li>$EVE_LIB  :eve lib folder</li>
<li>$MY_DIR   :program location</li>
<li>$MY_LIB   :project lib folder</li>
<li>$MY_LOG   :project log folder</li>
<li>$OS_PWD   :current working folder</li>
</ul>

<p><em>System objects</em> are instantiated at startup and are part of core library. These contain runtime information that you can use for debugging. System objects do not need module qualifier. You can access them directly once the module is imported.</p>

<ul>
<li>$error :contains last error with code & message</li>
<li>$stack :contains debug information about current call stack</li>
<li>$trace :contains reporting information about executed statements
</ul>

<p>Constants have at least first letter capitalized. The best practice is to use all capital letters for constants. The next symbols in a constant name can be numbers or underscore but no special or Unicode character.</p>

<h4>Example</h4>

<pre><code class="language-eve">
** gobal scope
global
  set $PI  = 3.14 :Float;      -- shared constant
  set $var = 0    :Integer;    -- shared variable
</code></pre>


<h4>Notes:</h4>
<ul>
<li>You can create new system constants and variables;</li>
<li>Prefix "$" is used to avoid scope/module qualifier;</li>
<li>OS environment variables are transferred to constants;</li>
<li>System constants are capitalized and also begin with "$";</li>
</ul>

<h3>Global states</h3>

<p>Global states are static variable defined in&nbsp;<em>global scope</em>&nbsp;. You can access global states in functions and methods without qualifier.</p>

<p>Global states can be constant or variables. Constants use capital letters while variables are using lowercase letters. First letter is important, other letters can be numbers, lowercase or uppercase letters or underscore.</p>


<h4>Example</h4>

<pre><code class="language-eve">
driver test():

** private class
class Person = {name:String, age:Integer} &lt;: Object;

** create states using type inference
global
  set  E = 2.52 :Real;    -- Euler's number
  set  x = 0    :Integer; -- private state

** create a global object of type Person.
process
  new  me := Person("Elucian", "56"); 
return;
</code></pre>

<h4>Notes:</h4>
<ul>
<li>All global states must be created using keyword "set", </li>
<li>All global states are bound to the current scope, </li>
<li>We are using operator "=" for initialization,</li>
<li>Constants are by convention using uppercase letters,</li>
<li>In the global regions you can not use type inference,</li>
</ul>

<h3>Import region</h3>

<p>The import is used to include public members from modules:</p>

<h4>Syntax:</h4>
<pre><code class="language-eve">
driver script_name:
  ** define global states
  set $user_path := root_path/relative_path;

import
  from $user_path use (module_name,...);  -- specific modules
  from $user_path use (*);                -- find all modules
  ...
alias
  ** create alias for some of the hidden members
  set new_name := module_name.member_name;
process
  ...
return;
</code></pre>

<h4>Notes:</h4>
<ul>
<li>$user_path is a shared variable defined by the user;</li>
<li>spaces in file-names are not supported you must use: "_";</li>
<li>aliases are created from public members of other module;</li>
</ul>

<h2><a id="library"></a>Library</h2>

<p>A&nbsp;<em>library</em>&nbsp;is a set of reusable modules. A library can be installed in EVE environment or can be project specific. EVE machine is using a special system variable to search for a library: $EVE_LIB. If the library is not found the module can't be imported and the script fails.</p>

<ul>
<li>libraries contain generic functionality and can be shared between multiple projects;</li>
<li>using import, several modules can be loaded from a library one by one or all using (*);</li>
<li>circular import is possible, but EVE prevent infinite recursive reference;</li>
<li>after import you can call public members of a module using&nbsp;<em>dot notation</em>;</li>
</ul>

<p><b>Note: </b>Library name is the name of the subfolder. Module is the name of the last folder in a path. By convention you can create intermediate subfolder but only the last folder is relevant and it must be unique in a library.<p>

<h2><a id="drivers"></a>Drivers</h2>

<p>A&nbsp;<em>driver</em>&nbsp;represents the application main script. It has the role to lead the application main process. When&nbsp;<em>driver</em>&nbsp;execution is over the application give control back to the EVE virtual machine. If no other process is running, the machine shuts-down after it clean-up the memory.</p>

<h4>Notes:</h4>
<ul>
<li>Any application can have one or more drivers,</li>
<li>A driver is the process entry point,</li>
<li>A driver can read configuration files at startup,</li>
<li>A driver can receive parameters;</li>
<li>A driver can have one single main process;</li>
<li>A driver is independent, can not be imported;</li>
</ul>

<h2><a id="aspects"></a>Aspects</h2>

<p>An <em>"aspect"</em> is a script specific to a particular project. It resolve a problem or address a specific concern. Aspect files are executable. One aspect can execute other aspects, however it can't be recursive.</p>

<p>An aspect can receive parameters. One aspect has a declaration region and an executable region. You can resolve an aspect by using keyword: "apply" or "start". An aspect must handle it's own errors. If errors are not handled, the program panic and stop execution.</p>

<h4>Syntax Pattern:</h4>

<pre><code class="language-eve">
aspect aspect_name(parameter_list):
  ** declare variables
  ...
process
  ** executable region
  ...
recover
  ** handle all errors
  ...
return;
</code></pre>

<p><b>Parameters</b>&nbsp; are defined in round brackets () separated by comma. Each parameter must have type and name. Using parameters require several conventions:</p>

<h4>Syntax:</h4>

<p>Mandatory parameters do not have initial values but only type. Optional parameters have initial value that is assign using operator "=" with explicit :type, or ":=" with type inference. Not both.</p>

<ul>
<li>parameter :Type</li>
<li>parameter  = value :Type</li>
<li>parameter := expression</li>
</ul>

<h4>Notes:</h4>

<ol>
<li>One aspect can receive one or more parameters,</li>
<li>Parameters having initial values are optional,</li>
<li>Values used for parameters at runtime, are called "arguments",</li>
<li>You can assign arguments by position using a list of values,</li>
<li>You can assign arguments by name using <code>(name:value)</code> pairs;</li>
</ol>

<p><b>Vararg parameters</b></p>
<p>One aspect can receive multiple arguments of the same type into a single collection parameter. This can be a List, DataSet or HashMap, depending on declaration.</p>

<ul>
<li>First arguments can be captured using named parameters,</li>
<li>The rest of arguments are captured into vararg parameter,</li>
<li>An aspect can have one single vararg parameter,</li>
<li>The vararg parameter name is declared using prefix: "*",</li>
<li>You can use any name but "*args" is the usual name for it.</li>
</ul>

<h4>Example:</h4>
<pre><code class="language-eve"># print all arguments
aspect test(*args: ()String):

** list all arguments
process
  cycle:
    new arg :String;
  for arg in args loop
    print arg;
  repeat;
return;
</code></pre>

<h4>Process context</h4>

<p>One script can have one single process. Every process has a local context. In this context you can define variables, and instantiate objects but you can't define routines, classes, methods or functions. Process local members can't be shared but can be send as input/output parameters to other subprograms.</p>

<h4>Output Parameters</h4>
<p>To avoid overuse of global variables you must use input/output parameters. We prefix output parameters using symbol "@". Output parameters require a variable as argument, otherwise you will not be able to capture the output value.</p>

<pre><code class="language-eve">
#demo output parameters
aspect output_params:

** private subroutine
routine add(p1 = 0, p2 = 1: Integer, @op: Integer):
  let op := p1 + p2;
return;

process 
  new result: Integer;

  ** inpur/output argument require a variable
  call add(1,2, op:result);
  print result;     -- expected value 3

  ** negative test, will fail
  call add(1,2,4); -- error, "out" parameter require a variable
return;
</code></pre>
 
<h4>Notes:</h4>
<ul>
<li>Output parameters are usually the last parameters;</li>
<li>Output parameters are having "@" prefix;</li>
<li>Routine invocation is done using a "call" statement;</li>
</ul>

<h2><a id="modules"></a>Modules</h2>

<p>Eve modules are abstract concepts. One module exist in a folder. A module consist of several scripts with extension ".eve". Modules can be combined together in large projects. Some modules are common for many projects. These are called system modules or library modules.</p>

<p>modules ...</p>
<ul>
<li>exist in a folder,</li>
<li>consist of *.eve scripts,</li>
<li>can use each other,</li>
<li>belong to one or more projects,</li>
<li>can define public or private members,</li>
<li>can be initialized when imported first time</li>
</ul>

<h4>Syntax Pattern:</h4>

<p>An Eve module begins with "module" keyword. Module name is the same as the last folder in a library path. A module can have an initialization region. This is executed when the module is imported for the first time.</p>

<pre><code class="language-eve">
+-----------------------------------------
module name is the folder name, so that
one module can have more then one scripts.    
-----------------------------------------+
module module_name:

** shared states
  set $system_variable: Type;
  ...

** import region
import
  from $path/library_name use (*);

** declare members
  ...
init
** setup initial states 
  let $system_variable := value;
  ...
release
** verify states & log
  $error.log();
  ... 
return;
</code></pre>

<h4>Notes:</h4>
<ul>
<li>Modules don't have parameters. You can not start a module;</li>
<li>Modules can define public members and shared states;</li>   
<li>Modules run in the main process or aspect processes;</li>
<li>A module "init" region is executed when module is imported;</li>
</ul>

<p><b>Module names </b>are using lowercase letters, can contain underscore or digits but no special characters and no Unicode strings. Longer names that use several words can be separate with underscore. The module name can be 30 characters long.</p>

<p><b>Module scripts </b>A module can be a single script file but usually represents several files. The main script has the same name as the module name. In the main script you can define ony the public members. In secondary scripts, you can define only the private members.</p>

<h2><a id="execution"></a>Script Execution</h2>

<p>Eve scripts are executed using a virtual machine. You can start the virtual machine as a service or as console application. In console you can&nbsp;<em>run</em>&nbsp;only a one driver script at a time. In service mode you can&nbsp;<em>run</em>&nbsp;multiple drivers. Each driver is independent and can't communicate with other drivers.</p>

<p><b>Configuration: &nbsp;</b>Eve services using a general configuration file: eve.cfg. This file contains default settings for EVE machine. System variables are shared. A copy of EVE system variables is send to every new driver instance.</p> 

<p>A driver can define default settings using "set". Configuration settings are loaded over the default values and have priority. In a process, you can temporary change the settings using let. These changes do not propagate back into the configuration file.</p>

<p><b>Memory allocation:&nbsp;</b>EVE service is in charge of allocating memory for each process. There is no shared memory between processes. When a process is terminated the memory is cleaned up of garbage and the machine continue to run until all processes are finished.</p>

<p>To execute a driver there are 2 methods:</p>
<ol>
<li>Using the "eve" system command with parameters,</li>
<li>Using console REPL commands with "load" command,</li>
<li>EVE virtual machine can be run as a daemon,</li>
<li>You can control EVE virtual machine using command: eve with parameters</li>
</ol>

<h3>Driver Execution:</h3>

<p>When a driver is loaded, all it's components are compiled in memory, then the <em>process</em> is executed. If a driver do not have a "process", it can be manually executed from eve console, one routine at a time.</p>

<h4>Start EVE REPL</h4>

<pre class="language-out">~/eve -c file.cfg</pre>

<h4>Running a Driver</h4>

<pre class="language-out">eve:&gt; load ~/path/driver_name.eve -c file.cfg -m 2048GB</pre>

<h4>Debug a Driver</h4>

<pre class="language-out">eve:&gt; debug ~/path/driver_name.eve -c file.cfg</pre>

<p>Eve REPL can be used to load or debug a driver manually, using special commands. The command options are not yet fully designed. We will implement these basic commands:</p>

<table class="table table-bordered">
<tr>
  <th>command</td>
  <th>description</td>
</tr>
<tr>
  <td>load</td>
  <td>compile a driver and execute the main process</td>
</tr>
<tr>
  <td>debug</td>
  <td>compile a driver but does not execute main process</td>
</tr>
<tr>
  <td>begin</td>
  <td>start the driver main process step by step execution</td>
</tr>
<tr>
  <td>enter</td>
  <td>this is actually the enter key. execute next step</td>
</tr>
<tr>
  <td>print</td>
  <td>display value for a global variable, it can't print locals</td>
</tr>
<tr>
  <td>resume</td>
  <td>continue running until a "halt" statement is encounter</td>
</tr> 
<tr>    
  <td>report</td>
  <td>create a debugging report about system state</td>
</tr>
<tr>    
  <td>stop</td>
  <td>stop the driver execution but do not clean memory</td>
</tr>
<tr>    
  <td>clear</td>
  <td>stop the driver and clean the memory</td>
</tr>
<tr> 
  <td>setup</td>
  <td>load configuration file and set "$" variables</td>     
</tr>
<tr>    
  <td>quit</td>
  <td>stop EVE machine and exit from REPL</td>
</tr>
</table>

<p>You can use "halt" inside the script to stop a script and debug the script later. "halt" is working only when debug mode is active. Statement "halt" can be conditioned with "if" to create a debugging break-point.</p>

<h3>Aspect Execution:</h3>

<p>One aspect is executed from driver or from another aspect. You can not execute an aspect from itself. Recursive aspects are not supported. The compiler will detect a recursive aspect and will fail at runtime.</p>

<p>You can debug an aspect just like a driver. You can load an aspect, execute the aspect step by step and create a report. Aspects are independent processes. However you can't debug aspects in parallel.</p>

<h4>Synchronously</h4>

<p>Aspects can be run in serial mode one after another. Let's consider we have 3 aspects: {one, two, three}. We can execute each aspect using keyword: "apply". This will interrupt the driver process and will execute aspect process one by one then return control to driver and continue the main process:</p>

<pre><code class="language-eve">
driver test_apply:

# synchronous call
process
  ** apply each aspect
  apply [folder/]aspect_one(arguments);
  apply [folder/]aspect_two(arguments);
  apply [folder/]aspect_three(arguments);
  ...
return;
</code></pre>

<p><b>Note: </b>You do not have to import an aspect into a driver but you must specify the relative path of the aspect. If the aspect is in a subfolder, you must include folder name. If the aspect is in the same location as the driver, you do not need a folder name.</p>

<h4>Asynchronously</h4>

<p>Aspects can be resolved in parallel mode using keyword "start".</p>

<pre><code class="language-eve">
# asynchronous call demo
driver async_demo:
process
  ** enqueue aspects to be resolved
  start [folder/]aspect_one(arguments);
  start [folder/]aspect_two(arguments);
  start [folder/]aspect_three(arguments);

  ** wait for all aspects to finish
  yield;
return;
</code></pre>

<h4>Parallel processes</h4>

<p>One script can start an aspect with different parameters.</p>

<pre><code class="language-eve">
** resolve several aspects
driver async_loop:
process
  ** enqueue same aspect 4 times
  cycle
    new i: Integer;
  for i in (1..4) loop
    start demo(i);
  repeat;
  yield;
return;
</code></pre>

<h3>Module import:</h3>

<p>The driver or aspect can import modules. After import, all public elements of modules can be used on demand. The parent process is controlling the execution. Modules are not directly executable.</p>

<p>Modules are "singleton" once a module is loaded in memory, it will not load a second time for same process. Eve is a multi-session system. Module states are bound the the current process.</p>

<h3>Exclusive mode:</h3>

<p>When a eve is executed, it can be started with parameter: -x or --exclusive. This is a signal that only one process can connect or use resources. In this mode "start" is not starting a new process but works like "apply" in serial mode. In this mode you can alter a database structure.</p>
 
<h2>Program Termination:</h2>

<p>Program can be early terminated be done using: <em>"over"</em> or <em>"panic"</em>. This is a way to release all locked resources and terminate the application. Program can end with an error code using "panic N" statement, otherwise it will automatically return 1 with panic and 0 with "over". Actually "panic 0" is equivalent to "over".</p>

<p>When drive is terminated, it depends what is happening next. When was started from a console in debug mode the module remains in memory, parsed and ready for debugging. The memory can be investigated using commands. When driver is executed in regular mode, the memory is erased and the EVE machine stop running.</p>

<h4>Example:</h4>

<p>Next code sequence is terminated after 100 iterations:</p>

<pre><code class="language-eve">
# terminate a program with: over
driver test_over:
process
  cycle:
    new i = 0 :Integer;
  loop
    write "."; wait  10;
    over if i > 10;
    let   i += 1;
  repeat;
return;
</code></pre>

<h2><a id="configuration"></a>Configuration</h2>

<p>EVE virtual machine can load system environment variables from a configuration file. These are stored as "$name:value" pairs. Some system constants can be derived from environment variables using concatenation operators "+", "/" or "\".</p>

<p>A configuration file have extension .cfg. One application can run with different configuration file. Application documentation must contain description of all variables required by the application.</p>

<p>A good practice is to provide a configuration <em>template</em>&nbsp;. The template file may contain comments and $key = value pairs. Values can be numeric, string, symbol, date, time or data literals: [],(),{}. Eve application will automatically parse configuration file to read values for the <em>system variables</em>.</p>

<p>In debug mode you can modify the configuration and reload using "setup" command. REPL must be in "ready" state when you reload settings otherwise you will get an error.</p>
<!-- work in progress-->

<hr>
<p><b>Read next:</b>
<a href="types.html">Data Types</a></p>

<!-- Footer -->
<footer class="footer">
  <div class="footer-copyright text-center"></div>
</footer>
</div>
</body>
</html>